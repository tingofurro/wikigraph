



This article needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed. (March 2015)





This article may be too technical for most readers to understand. Please help improve this article to make it understandable to non-experts, without removing the technical details. The talk page may contain suggestions. (November 2009)




Graph and tree
search algorithms





α–β
A*
B*
Backtracking
Beam
Bellman–Ford
Best-first
Bidirectional
Borůvka
Branch &amp; bound
BFS
British Museum
D*
DFS
Depth-limited
Dijkstra
Edmonds
Floyd–Warshall
Fringe search
Hill climbing
IDA*
Iterative deepening
Johnson
Jump point
Kruskal
Lexicographic BFS
Prim
SMA*




Listings




Graph algorithms
Search algorithms
List of graph algorithms




Related topics




Dynamic programming
Graph traversal
Tree traversal
Search games







v
t
e





SMA* or Simplified Memory Bounded A* is a shortest path algorithm based on the A* algorithm. The main advantage of SMA* is that it uses a bounded memory, while the A* algorithm might need exponential memory. All other characteristics of SMA* are inherited from A*.



Contents


1 Process
2 Properties
3 Implementation
4 References




Process[edit]

Like A*, it expands the most promising branches according to the heuristic. What sets SMA* apart is that it prunes nodes whose expansion has revealed less promising than expected. The approach allows the algorithm to explore branches and backtrack to explore other branches.
Expansion and pruning of nodes is driven by keeping two values of  for every node. Node  stores a value  which estimates the cost of reaching the goal by taking a path through that node. The lower the value, the higher the priority. As in A* this value is initialized to , but will then be updated to reflect changes to this estimate when its children are expanded. A fully expanded node will have an  value at least as high as that of its successors. In addition, the node stores the  value of the best forgotten successor. This value is restored if the forgotten successor is revealed to be the most promising successor.
Starting with the first node, it maintains OPEN, ordered lexicographically by  and depth. When choosing a node to expand, it chooses the best according to that order. When selecting a node to prune, it chooses the worst.

Properties[edit]

SMA* has the following properties

It works with a heuristic, just as A*
It is complete if the allowed memory is high enough to store the shallowest solution
It is optimal if the allowed memory is high enough to store the shallowest optimal solution, otherwise it will return the best solution that fits in the allowed memory
It avoids repeated states as long as the memory bound allows it
It will use all memory available
Enlarging the memory bound of the algorithm will only speed up the calculation
When enough memory is available to contain the entire search tree, then calculation has an optimal speed


Implementation[edit]

The implementation of SMA* is very similar to the one of A*, the only difference is that when there isn't any space left, nodes with the highest f-cost are pruned from the queue. Because those nodes are deleted, the SMA* also has to remember the f-cost of the best forgotten child with the parent node. When it seems that all explored paths are worse than such a forgotten path, the path is re-generated.[1]
Pseudo code:



function SMA-star(problem): path
  queue: set of nodes, ordered by f-cost;
begin
  queue.insert(problem.root-node);
 
  while True do begin
    if queue.empty() then return failure; //there is no solution that fits in the given memory
    node := queue.begin(); // min-f-cost-node
    if problem.is-goal(node) then return success;
 
    s := next-successor(node)
    if !problem.is-goal(s) &amp;&amp; depth(s) == max_depth then
        f(s) := inf; 
        // there is no memory left to go past s, so the entire path is useless
    else
        f(s) := max(f(node), g(s) + h(s));
        // f-value of the successor is the maximum of
        //      f-value of the parent and 
        //      heuristic of the successor + path length to the successor
    endif
    if no more successors then
       update f-cost of node and those of its ancestors if needed
 
    if node.successors ⊆ queue then queue.remove(node); 
    // all children have already been added to the queue via a shorter way
    if memory is full then begin
      badNode := shallowest node with highest f-cost;
      for parent in badNode.parents do begin
        parent.successors.remove(badNode);
        if needed then queue.insert(parent); 
      endfor
    endif
 
    queue.insert(s);
  endwhile
end



